package com.nanyang.richeditor.database;

import static com.nanyang.richeditor.database.DatabaseModel.NEW_MODEL_ID;
import static com.nanyang.richeditor.database.DatabaseUtils.readJsonFromPath;

import android.annotation.SuppressLint;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;

import com.nanyang.richeditor.App;
import com.nytaiji.nybase.utils.NyFileUtil;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.io.FileOutputStream;
import java.util.ArrayList;
import java.util.Locale;
import java.util.Objects;
public class DatabaseManager {

    //the position is not saved in database
    public static final int SORT_TITLE_ASC = 0;
    public static final int SORT_TITLE_DESC = 1;
    public static final int SORT_DATE_ASC = 2;
    public static final int SORT_DATE_DESC = 3;

    /**
     * The singleton instance of Controller class
     */
    private static DatabaseManager instance = null;

    private SQLiteOpenHelper helper;

    private final String[] sorts = {
            DbHelper.COLUMN_TITLE + " ASC",
            DbHelper.COLUMN_TITLE + " DESC",
            DbHelper.COLUMN_DATE + " ASC",
            DbHelper.COLUMN_DATE + " DESC"
    };

    public DatabaseManager(Context context) {
        helper = App.getDbHelper();
        instance = this;
    }

    /**
     * Reads all notes or categories from database
     *
     * @param cls         the class of the model type
     * @param columns     the columns must be returned from the query
     * @param where       the where clause of the query.
     * @param whereParams the parameters of where clause.
     * @param sortId      the sort id of categories or notes
     * @param <T>         a type which extends DatabaseModel
     * @return a list of notes or categories
     */
    public <T extends Database> ArrayList<T> findNotes(Class<T> cls, String[] columns, String where, String[] whereParams, int sortId) {
        ArrayList<T> items = new ArrayList<>();

        SQLiteDatabase db = helper.getReadableDatabase();
        try {
            Cursor c = db.query(
                    DbHelper.TABLE_NOTES,
                    columns,
                    where,
                    whereParams,
                    null, null,
                    sorts[sortId]
            );

            if (c != null) {
                while (c.moveToNext()) {
                    try {
                        items.add(cls.getDeclaredConstructor(Cursor.class).newInstance(c));
                    } catch (Exception ignored) {
                    }
                }

                c.close();
            }

            return items;
        } finally {
            db.close();
        }
    }

    /**
     * Reads a note or category from the database
     *
     * @param cls the class of the model type
     * @param id  primary key of note or category
     * @param <T> a type which extends DatabaseModel
     * @return a new object of T type
     */
    public <T extends Database> T findNote(Class<T> cls, long id) {
        SQLiteDatabase db = helper.getReadableDatabase();

        try {
            Cursor cursor = db.query(
                    DbHelper.TABLE_NOTES,
                    null,
                    DbHelper.COLUMN_ID + " = ?",
                    new String[]{
                            String.format(Locale.US, "%d", id)
                    },
                    null, null, null
            );

            if (cursor == null) return null;

            if (cursor.moveToFirst()) {
                try {
                    return cls.getDeclaredConstructor(Cursor.class).newInstance(cursor);
                } catch (Exception e) {
                    return null;
                }
            }

            return null;
        } finally {
            db.close();
        }
    }

    /**
     * Change the amount of category counter
     *
     * @param categoryId the id of category
     * @param amount     to be added (negative or positive)
     */
    public void addCategoryCounter(long categoryId, int amount) {
        SQLiteDatabase db = helper.getWritableDatabase();

        try {
            db.execSQL(
                    "UPDATE " + DbHelper.TABLE_NOTES + " SET " + DbHelper.COLUMN_COUNTER + " = " + DbHelper.COLUMN_COUNTER + " + ? WHERE " + DbHelper.COLUMN_ID + " = ?",
                    new String[]{String.valueOf(amount), String.valueOf(categoryId)}
            );
        } finally {
            db.close();
        }
    }

    /**
     * Restores last deleted notes
     */
    public void undoDeletion() {
        SQLiteDatabase db = helper.getWritableDatabase();

        try {
            Cursor cursor = db.query(
                    DbHelper.TABLE_UNDO,
                    null, null, null, null, null, null
            );

            if (cursor != null) {
                while (cursor.moveToNext()) {
                    @SuppressLint("Range") String query = cursor.getString(cursor.getColumnIndex(DbHelper.COLUMN_SQL));
                    if (query != null) {
                        db.execSQL(query);
                    }
                }

                cursor.close();
            }

            clearUndoTable(db);
        } finally {
            db.close();
        }
    }

    /**
     * Clears the undo table
     *
     * @param db an object of writable SQLiteDatabase
     */
    public void clearUndoTable(SQLiteDatabase db) {
        db.execSQL("DELETE FROM " + DbHelper.TABLE_UNDO);
    }

    /**
     * Deletes a note or category (and its children) from the database
     *
     * @param ids        a list of the notes' IDs
     * @param categoryId the id of parent category
     */
    public void deleteNotes(String[] ids, long categoryId) {
        SQLiteDatabase db = helper.getWritableDatabase();

        try {
            clearUndoTable(db);

            StringBuilder where = new StringBuilder();
            StringBuilder childWhere = new StringBuilder();

            boolean needOR = false;
            for (String id : ids) {
                if (needOR) {
                    where.append(" OR ");
                    childWhere.append(" OR ");
                } else {
                    needOR = true;
                }
                where.append(DbHelper.COLUMN_ID).append(" = ?");
                childWhere.append(DbHelper.COLUMN_PARENT_ID).append(" = ?");
            }

            int count = db.delete(
                    DbHelper.TABLE_NOTES,
                    where.toString(),
                    ids
            );

            if (categoryId == Database.NEW_MODEL_ID) {
                db.delete(
                        DbHelper.TABLE_NOTES,
                        childWhere.toString(),
                        ids
                );
            } else {
                db.execSQL(
                        "UPDATE " + DbHelper.TABLE_NOTES + " SET " + DbHelper.COLUMN_COUNTER + " = " + DbHelper.COLUMN_COUNTER + " - ? WHERE " + DbHelper.COLUMN_ID + " = ?",
                        new String[]{String.valueOf(count), String.valueOf(categoryId)}
                );
            }
        } finally {
            db.close();
        }
    }

    /**
     * Inserts or updates a note or category in the database and increments the counter
     * of category if the deleted object is an instance of Note class
     *
     * @param note   the object of type T
     * @param values ContentValues of the object to be inserted or updated
     * @param <T>    a type which extends DatabaseModel
     * @return the id of saved note
     */
    public <T extends Database> long saveNote(T note, ContentValues values) {
        SQLiteDatabase db = helper.getWritableDatabase();

        try {
            if (note.id > Database.NEW_MODEL_ID) {
                // Update note
                note.modifyDate = System.currentTimeMillis();
                values.put(DbHelper.COLUMN_MODIFICATION, note.modifyDate);
                db.update(
                        DbHelper.TABLE_NOTES,
                        values,
                        DbHelper.COLUMN_ID + " = ?",
                        new String[]{String.valueOf(note.id)}
                );
                return note.id;
            } else {
                // Create a new note
                long currentTime = System.currentTimeMillis();
                note.creationDate = currentTime;
                note.modifyDate = currentTime;
                values.put(DbHelper.COLUMN_DATE, note.creationDate);
                values.put(DbHelper.COLUMN_MODIFICATION, note.modifyDate);
                note.id = db.insert(
                        DbHelper.TABLE_NOTES,
                        null,
                        values
                );

                if (note instanceof Note) {
                    // Increment the counter of category
                    db.execSQL(
                            "UPDATE " + DbHelper.TABLE_NOTES + " SET " + DbHelper.COLUMN_COUNTER + " = " + DbHelper.COLUMN_COUNTER + " + 1 WHERE " + DbHelper.COLUMN_ID + " = ?",
                            new String[]{String.valueOf(((Note) note).parentId)}
                    );
                }

                return note.id;
            }
        } catch (Exception e) {
            return Database.NEW_MODEL_ID;
        } finally {
            db.close();
        }
    }

    /**
     * Reads a category by its id
     *
     * @param id primary key of category
     * @return the category object or null if it was not found
     */
    public Category findCategoryById(long id) {
        return findNote(Category.class, id);
    }

    /**
     * Reads all categories
     *
     * @return a list of categories which is populated by database
     */
    // TODO ny not include body to save memory  T
    public ArrayList<Category> findAllCategories() {
        return findNotes(
                Category.class,
                new String[]{
                        DbHelper.COLUMN_ID,
                        DbHelper.COLUMN_TITLE,
                        DbHelper.COLUMN_KEYWORDS,
                        DbHelper.COLUMN_REMARK,
                        DbHelper.COLUMN_DATE,
                        DbHelper.COLUMN_MODIFICATION, // Include modification date
                        DbHelper.COLUMN_TYPE,
                        DbHelper.COLUMN_ARCHIVED,
                        DbHelper.COLUMN_PROTECT,
                        DbHelper.COLUMN_STARED,
                        DbHelper.COLUMN_THEME,
                        DbHelper.COLUMN_COUNTER,
                        DbHelper.COLUMN_EXTRA
                },
                DbHelper.COLUMN_TYPE + " = ? AND " + DbHelper.COLUMN_ARCHIVED + " = ?",
                new String[]{
                        String.valueOf(Database.TYPE_CATEGORY),
                        "0"
                },
                App.sortCategoriesBy
        );
    }

    /**
     * @return a category id by title, to ensure a unique title
     */
    public Long categoryIdbyTitle(String title) {
        ArrayList<Category> all = findAllCategories();
        for (Category c : all) {
            if (Objects.equals(c.title, title)) return c.id;
        }
        //create a new Category with title
        Category category = new Category();
        category.id = Database.NEW_MODEL_ID;
        category.title = title;
        return category.save();
    }

    /**
     * Reads a note by its id
     *
     * @param id primary key of note
     * @return the note object or null if it was not found
     */
    public Note findNote(long id) {
        return findNote(Note.class, id);
    }

    /**
     * Reads all notes
     *
     * @param categoryId the id of parent category
     * @return a list of notes which is populated by database
     */
    public ArrayList<Note> findAllNotesInCategory(long categoryId) {
        String sort = findCategoryById(categoryId).sortBy;
        int sortBy = sort == null || sort.isEmpty() ? App.sortNotesBy : Integer.parseInt(sort);
        return findNotes(
                Note.class,
                new String[]{
                        DbHelper.COLUMN_ID,
                        DbHelper.COLUMN_TITLE,
                        DbHelper.COLUMN_KEYWORDS,
                        DbHelper.COLUMN_REMARK,
                        DbHelper.COLUMN_DATE,
                        DbHelper.COLUMN_MODIFICATION, // Include modification date
                        DbHelper.COLUMN_TYPE,
                        DbHelper.COLUMN_ARCHIVED,
                        DbHelper.COLUMN_PARENT_ID,
                        DbHelper.COLUMN_PROTECT,
                        DbHelper.COLUMN_STARED,
                        DbHelper.COLUMN_EXTRA
                },
                DbHelper.COLUMN_TYPE + " != ? AND " + DbHelper.COLUMN_PARENT_ID + " = ? AND " + DbHelper.COLUMN_ARCHIVED + " = ?",
                new String[]{
                        String.valueOf(Database.TYPE_CATEGORY),
                        String.valueOf(categoryId),
                        "0"
                },

                sortBy
        );
    }

    //TODO ny


    public ArrayList<Note> dateSearch(String date, boolean isEarlier) {

        return findNotes(
                Note.class,
                new String[]{
                        DbHelper.COLUMN_ID,
                        DbHelper.COLUMN_TITLE,
                        DbHelper.COLUMN_KEYWORDS,
                        DbHelper.COLUMN_REMARK,
                        DbHelper.COLUMN_DATE,
                        DbHelper.COLUMN_MODIFICATION, // Include modification date
                        DbHelper.COLUMN_TYPE,
                        DbHelper.COLUMN_ARCHIVED,
                        DbHelper.COLUMN_PARENT_ID,
                        DbHelper.COLUMN_PROTECT,
                        DbHelper.COLUMN_STARED,
                        DbHelper.COLUMN_EXTRA
                },
                isEarlier ? DbHelper.COLUMN_DATE + "<= ?" : DbHelper.COLUMN_DATE + ">= ?",
                new String[]{
                        date
                },
                App.sortNotesBy
        );
    }

    public ArrayList<Note> starSearch() {
        return findNotes(
                Note.class,
                new String[]{
                        DbHelper.COLUMN_ID,
                        DbHelper.COLUMN_TITLE,
                        DbHelper.COLUMN_KEYWORDS,
                        DbHelper.COLUMN_REMARK,
                        DbHelper.COLUMN_DATE,
                        DbHelper.COLUMN_MODIFICATION, // Include modification date
                        DbHelper.COLUMN_TYPE,
                        DbHelper.COLUMN_ARCHIVED,
                        DbHelper.COLUMN_PARENT_ID,
                        DbHelper.COLUMN_PROTECT,
                        DbHelper.COLUMN_STARED,
                        DbHelper.COLUMN_EXTRA
                },
                DbHelper.COLUMN_STARED + "= ? AND " + DbHelper.COLUMN_TYPE + " != ?",
                new String[]{
                        "1",
                        "0"
                },
                App.sortNotesBy
        );
    }


    public ArrayList<Note> simpleSearch(String searchKey) {
        searchKey = searchKey.trim();

        return findNotes(
                Note.class,
                new String[]{
                        DbHelper.COLUMN_ID,
                        DbHelper.COLUMN_TITLE,
                        DbHelper.COLUMN_KEYWORDS,
                        DbHelper.COLUMN_REMARK,
                        DbHelper.COLUMN_DATE,
                        DbHelper.COLUMN_MODIFICATION, // Include modification date
                        DbHelper.COLUMN_TYPE,
                        DbHelper.COLUMN_ARCHIVED,
                        DbHelper.COLUMN_PARENT_ID,
                        DbHelper.COLUMN_PROTECT,
                        DbHelper.COLUMN_STARED,
                        DbHelper.COLUMN_EXTRA
                },
                DbHelper.COLUMN_TITLE + " like ? AND " + DbHelper.COLUMN_TYPE + " != ?  OR "
                        + DbHelper.COLUMN_KEYWORDS + " like ? OR "
                        + DbHelper.COLUMN_REMARK + " like ?",
                new String[]{
                        "%" + searchKey + "%",
                        "0",
                        "%" + searchKey + "%",
                        "%" + searchKey + "%"
                },

                App.sortNotesBy
        );
    }

    public ArrayList<Note> deepSearch(String searchKey) {
        searchKey = searchKey.trim();
        if (searchKey.isEmpty()) return null;
        return findNotes(
                Note.class,
                new String[]{
                        DbHelper.COLUMN_ID,
                        DbHelper.COLUMN_TITLE,
                        DbHelper.COLUMN_KEYWORDS,
                        DbHelper.COLUMN_REMARK,
                        DbHelper.COLUMN_DATE,
                        DbHelper.COLUMN_MODIFICATION, // Include modification date
                        DbHelper.COLUMN_TYPE,
                        DbHelper.COLUMN_ARCHIVED,
                        DbHelper.COLUMN_PARENT_ID,
                        DbHelper.COLUMN_PROTECT,
                        DbHelper.COLUMN_STARED,
                        DbHelper.COLUMN_EXTRA
                },
                DbHelper.COLUMN_TITLE + " like ? AND " + DbHelper.COLUMN_TYPE + " != ?  OR "
                        + DbHelper.COLUMN_KEYWORDS + " like ? OR "
                        + DbHelper.COLUMN_REMARK + " like ?  OR "
                        + DbHelper.COLUMN_BODY + " like ? ",
                new String[]{
                        "%" + searchKey + "%",
                        "0",
                        "%" + searchKey + "%",
                        "%" + searchKey + "%",
                        "%" + searchKey + "%"
                },

                App.sortNotesBy
        );
    }

    public String idToTitle(long id) {
        return findNote(id).title;
    }

    //to check whether the title has been used in the same category, return -1 for unused.
    public long titleToId(long parentId, String title) {
        ArrayList<Note> all = findAllNotesInCategory(parentId);
        for (Note note : all) {
            if (note.title.equals(title)) return note.id;
        }
        return NEW_MODEL_ID;
    }

    public long titleToId(String title) {
        ArrayList<Note> all = simpleSearch(title);
        for (Note note : all) {
            if (note.title.equals(title)) return note.id;
        }
        return NEW_MODEL_ID;
    }

    public String formatTitle(long parentId, String title) {
        int i = 2;
        //auto correction of space in the title
        String newTitle = title.replace(" ", "_");
        while (titleToId(parentId, newTitle) != NEW_MODEL_ID) {
            newTitle = String.format(Locale.US, "%s(%d)", title, i);
            i++;
        }
        return newTitle;
    }


    /**
     * Writes data to file
     *
     * @param fos an object of FileOutputStream
     * @throws Exception
     */
    public void writeBackup(FileOutputStream fos) throws Exception {
        ((DbHelper) helper).saveToJson(fos);
    }

    /**
     * Reads data from a JSON object
     *
     * @param jsonObject the JSON object containing notes and metadata arrays
     * @throws Exception
     */
    public void readBackup(JSONObject jsonObject) throws Exception {
       // SQLiteDatabase db = helper.getWritableDatabase();  // Should use getWritableDatabase for write operations
        jsonToDatabase((DbHelper) helper, jsonObject);
    }

    public void jsonToDatabase(DbHelper dbHelper, JSONObject jsonObject) throws Exception {
        SQLiteDatabase db = dbHelper.getWritableDatabase();
        try {
            // Process notes array
            if (jsonObject.has(DbHelper.TABLE_NOTES)) {
                JSONArray notesArray = jsonObject.getJSONArray(DbHelper.TABLE_NOTES);
                int notesLength = notesArray.length();

                for (int i = 0; i < notesLength; i++) {
                    JSONObject item = notesArray.getJSONObject(i);
                    ContentValues values = new ContentValues();
                    values.put(DbHelper.COLUMN_ID, item.getLong(DbHelper.COLUMN_ID));
                    values.put(DbHelper.COLUMN_TITLE, item.getString(DbHelper.COLUMN_TITLE).replace(" ", "_"));

                    try {
                        values.put(DbHelper.COLUMN_KEYWORDS, item.getString(DbHelper.COLUMN_KEYWORDS));
                    } catch (JSONException e) {
                        values.put(DbHelper.COLUMN_KEYWORDS, "");
                    }
                    try {
                        values.put(DbHelper.COLUMN_REFERENCE, item.getString(DbHelper.COLUMN_REFERENCE));
                    } catch (JSONException e) {
                        values.put(DbHelper.COLUMN_REFERENCE, "");
                    }
                    try {
                        values.put(DbHelper.COLUMN_REMARK, item.getString(DbHelper.COLUMN_REMARK));
                    } catch (JSONException e) {
                        values.put(DbHelper.COLUMN_REMARK, "");
                    }
                    try {
                        values.put(DbHelper.COLUMN_BODY, item.getString(DbHelper.COLUMN_BODY));
                    } catch (JSONException e) {
                        values.put(DbHelper.COLUMN_BODY, "");
                    }
                    try {
                        values.put(DbHelper.COLUMN_EXTRA, item.getString(DbHelper.COLUMN_EXTRA));
                    } catch (JSONException e) {
                        values.put(DbHelper.COLUMN_EXTRA, "");
                    }

                    values.put(DbHelper.COLUMN_TYPE, item.getInt(DbHelper.COLUMN_TYPE));
                    values.put(DbHelper.COLUMN_DATE, item.getString(DbHelper.COLUMN_DATE));
                    values.put(DbHelper.COLUMN_MODIFICATION, item.getString(DbHelper.COLUMN_MODIFICATION));
                    values.put(DbHelper.COLUMN_ARCHIVED, item.getInt(DbHelper.COLUMN_ARCHIVED));
                    values.put(DbHelper.COLUMN_PROTECT, item.getInt(DbHelper.COLUMN_PROTECT));
                    values.put(DbHelper.COLUMN_STARED, item.getInt(DbHelper.COLUMN_STARED));
                    values.put(DbHelper.COLUMN_THEME, item.getInt(DbHelper.COLUMN_THEME));
                    values.put(DbHelper.COLUMN_COUNTER, item.getInt(DbHelper.COLUMN_COUNTER));
                    values.put(DbHelper.COLUMN_PARENT_ID, item.getLong(DbHelper.COLUMN_PARENT_ID));

                    db.replace(DbHelper.TABLE_NOTES, null, values);
                }
            }

            // Process metadata array
            if (jsonObject.has(DbHelper.TABLE_SYNC)) {
                JSONArray metadataArray = jsonObject.getJSONArray(DbHelper.TABLE_SYNC);
                int metadataLength = metadataArray.length();

                for (int i = 0; i < metadataLength; i++) {
                    JSONObject item = metadataArray.getJSONObject(i);
                    ContentValues values = new ContentValues();
                    values.put(DbHelper.COLUMN_KEY, item.getString(DbHelper.COLUMN_KEY));
                    values.put(DbHelper.COLUMN_VALUE, item.getString(DbHelper.COLUMN_VALUE));

                    db.replace(DbHelper.TABLE_SYNC, null, values);
                }
            }
        } finally {
            db.close();
        }
    }


    public void jsonToDatabase(Context context, String jsonPath, String dataName) throws Exception {
        // Step 1: Read JSON data from the backup file
        JSONObject jsonObject = readJsonFromPath(jsonPath);
        File tempDbFile = new File(NyFileUtil.getAppDirectory(context), dataName);
        DbHelper tempDbHelper = new DbHelper(context, tempDbFile.getAbsolutePath());
        jsonToDatabase(tempDbHelper, jsonObject);

        // Manual Cleanup extra zero-byte -journal
        File journalFile = new File(tempDbFile.getAbsolutePath() + "-journal");
        if (journalFile.exists() && journalFile.length() == 0) {
            boolean deleted = journalFile.delete();
            if (!deleted) {
                // Log the failure to delete the journal file or handle it accordingly
                Log.e("DatabaseCleanup", "Failed to delete the zero-byte journal file.");
            }
        }
    }
}

/*
    public void jsonToDatabase(DbHelper dbHelper, JSONObject jsonObject) throws Exception {
        SQLiteDatabase db = dbHelper.getWritableDatabase();
        db.beginTransaction(); // Begin transaction
        try {
            // Process notes array
            if (jsonObject.has(DbHelper.TABLE_NOTES)) {
                JSONArray notesArray = jsonObject.getJSONArray(DbHelper.TABLE_NOTES);
                int notesLength = notesArray.length();

                for (int i = 0; i < notesLength; i++) {
                    JSONObject item = notesArray.getJSONObject(i);
                    ContentValues values = new ContentValues();
                    values.put(DbHelper.COLUMN_ID, item.getLong(DbHelper.COLUMN_ID));
                    values.put(DbHelper.COLUMN_TITLE, item.getString(DbHelper.COLUMN_TITLE).replace(" ", "_"));

                    values.put(DbHelper.COLUMN_KEYWORDS, item.optString(DbHelper.COLUMN_KEYWORDS, ""));
                    values.put(DbHelper.COLUMN_REFERENCE, item.optString(DbHelper.COLUMN_REFERENCE, ""));
                    values.put(DbHelper.COLUMN_REMARK, item.optString(DbHelper.COLUMN_REMARK, ""));
                    values.put(DbHelper.COLUMN_BODY, item.optString(DbHelper.COLUMN_BODY, ""));
                    values.put(DbHelper.COLUMN_EXTRA, item.optString(DbHelper.COLUMN_EXTRA, ""));
                    values.put(DbHelper.COLUMN_TYPE, item.getInt(DbHelper.COLUMN_TYPE));
                    values.put(DbHelper.COLUMN_DATE, item.getString(DbHelper.COLUMN_DATE));
                    values.put(DbHelper.COLUMN_MODIFICATION, item.getString(DbHelper.COLUMN_MODIFICATION));
                    values.put(DbHelper.COLUMN_ARCHIVED, item.getInt(DbHelper.COLUMN_ARCHIVED));
                    values.put(DbHelper.COLUMN_PROTECT, item.getInt(DbHelper.COLUMN_PROTECT));
                    values.put(DbHelper.COLUMN_STARED, item.getInt(DbHelper.COLUMN_STARED));
                    values.put(DbHelper.COLUMN_THEME, item.getInt(DbHelper.COLUMN_THEME));
                    values.put(DbHelper.COLUMN_COUNTER, item.getInt(DbHelper.COLUMN_COUNTER));
                    values.put(DbHelper.COLUMN_PARENT_ID, item.getLong(DbHelper.COLUMN_PARENT_ID));

                    db.replace(DbHelper.TABLE_NOTES, null, values);
                }
            }

            // Process metadata array
            if (jsonObject.has(DbHelper.TABLE_SYNC)) {
                JSONArray metadataArray = jsonObject.getJSONArray(DbHelper.TABLE_SYNC);
                int metadataLength = metadataArray.length();

                for (int i = 0; i < metadataLength; i++) {
                    JSONObject item = metadataArray.getJSONObject(i);
                    ContentValues values = new ContentValues();
                    values.put(DbHelper.COLUMN_KEY, item.getString(DbHelper.COLUMN_KEY));
                    values.put(DbHelper.COLUMN_VALUE, item.getString(DbHelper.COLUMN_VALUE));

                    db.replace(DbHelper.TABLE_SYNC, null, values);
                }
            }

            db.setTransactionSuccessful(); // Mark the transaction as successful
        } finally {
            db.endTransaction(); // End transaction
            db.close();
        }
    }

    public void jsonToDatabase(Context context, String jsonPath, String dataName) throws Exception {
        // Step 1: Read JSON data from the backup file
        JSONObject jsonObject = readJsonFromPath(jsonPath);

        // Step 2: Create a temporary database in external storage
        File tempDbFile = new File(NyFileUtil.getAppDirectory(context), dataName);
        DbHelper tempDbHelper = new DbHelper(context, tempDbFile.getAbsolutePath());

        SQLiteDatabase db = tempDbHelper.getWritableDatabase();
        db.rawQuery("PRAGMA journal_mode=WAL;", null).close(); // Set WAL mode properly
        db.close(); // Close immediately after setting WAL mode

        jsonToDatabase(tempDbHelper, jsonObject);
    }

 */
